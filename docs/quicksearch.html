<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"BookshelfMapping.js.html":{"id":"BookshelfMapping.js.html","title":"Source: BookshelfMapping.js","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Source: BookshelfMapping.js \"use strict\"; const StringUtils = require(\"./StringUtils\"); const { required } = require(\"./Annotations\"); /** * Describes a DB Mapping * * @property {string} tableName - Fully qualified name of DB Table * @property {string} [identifiedBy = \"id\"] - Primary key column * @property {Array&lt;String | ColumnDescriptor&gt;} [columns] - columns to fetch. 'underscore_space' will be converted to 'lowerCamelCase' in Entity * @property {Object | Function} [discriminator] - Fetch only Entities which match a given query, Knex where condition * @property {Object} [onDelete] - Execute instead of regular delete statement, Knex update statement * * @property {Boolean} [keepHistory = false] - Keep an History History in this table. New states are appended instead of updated. * Columns 'revision_id' and 'parent_id' will be added to mapping, thus requires these columns in DB. * 'revision_id' must have a unique default value, is the Primary Key at best. * 'identifiedBy' must not be the Primary Key, since many revisions with the same ID can exist. * * @property {Boolean} [historyColumns = { revisionId: \"revision_id\", parentId: \"parent_id\" }] - Configure alias for history columns * * @property {Array&lt;RelationDescriptor&gt;} [relations] - Managed relations of this Entity. * There will be a getter and setter for n:1 relations * There will be a getter and modifiers (\"add\"/\"remove\" + relation.name) for m:n relations */ class BookshelfMapping { constructor(dbContext, config) { this.dbContext = dbContext; this.tableName = config.tableName; this.identifiedBy = BookshelfMapping.getOptionOrDefault(config.identifiedBy, \"id\"); this.relations = BookshelfMapping.getOptionOrDefault(config.relations, []); this.relationNames = BookshelfMapping.getOptionOrDefault(this.relations, []).map((r) =&gt; r.name); this.columns = BookshelfMapping.getOptionOrDefault(config.columns, []); this.discriminator = config.discriminator; this.onDelete = config.onDelete; this.keepHistory = BookshelfMapping.getOptionOrDefault(config.keepHistory, false); this.historyColumns = BookshelfMapping.getOptionOrDefault(config.historyColumns, { revisionId: \"revision_id\", parentId: \"parent_id\" }); this.configureHistory(); this.Model = this.createModel(); this.Collection = this.createCollection(); this.startTransaction = dbContext.transaction.bind(dbContext); this.deriveColumnAccessors(); this.provideForeignKeyColumnsToRelatedMappings(this.relations); } static getOptionOrDefault(configProperty, defaultValue) { return configProperty || defaultValue; } configureHistory() { if (this.keepHistory) { this.discriminator = this.addHistoryDiscriminator(); const columns = new Set(this.columns).add(this.historyColumns.revisionId).add(this.historyColumns.parentId); this.columns = [...columns]; } } addHistoryDiscriminator() { const discriminator = this.discriminator; const { revisionId, parentId } = this.historyColumns; return (q) =&gt; { q.whereNotIn(revisionId, (q) =&gt; q.from(this.tableName).whereNotNull(parentId).select(parentId)); q.andWhere(discriminator); }; } deriveColumnAccessors() { this.columnMappings = this.columns.map((column) =&gt; typeof column === \"string\" ? { name: column } : column); this.columnNames = this.columnMappings.map((column) =&gt; column.name); this.regularColumns = this.columnMappings.filter((c) =&gt; c.type !== \"sql\"); this.regularColumnNames = this.regularColumns.map((column) =&gt; column.name); this.sqlColumns = this.columnMappings.filter((c) =&gt; c.type === \"sql\"); this.writeableSqlColumns = this.sqlColumns.filter((c) =&gt; c.set); this.readableSqlColumns = this.sqlColumns.filter((c) =&gt; c.get); this.qualifiedRegularColumnNames = this.relations .filter((r) =&gt; r.type === \"belongsTo\") .map((r) =&gt; r.references.mappedBy) .concat(this.regularColumnNames) .map((name) =&gt; `${this.tableName}.${name}`); } provideForeignKeyColumnsToRelatedMappings() { this.relations.filter((r) =&gt; r.type === \"hasMany\" || r.type === \"hasOne\").forEach((r) =&gt; { r.references.mapping.qualifiedRegularColumnNames.push(r.references.mappedBy); }); } createModel() { const prototype = { tableName: this.tableName, idAttribute: this.identifiedBy }; this.relations.forEach(this.addRelation.bind(this, prototype)); return this.dbContext.Model.extend(prototype); } createCollection() { return this.dbContext.Collection.extend({ model: this.Model }); } addRelation(prototype, relation) { const relationName = StringUtils.camelToSnakeCase(relation.name); const fkName = relation.references.mappedBy = relation.references.mappedBy || relationName + \"_id\"; prototype[\"relation_\" + relation.name] = function () { if (!(relation.type in this)) { throw new Error(\"Relation of type '\" + relation.type + \"' doesn't exist\"); } const referencedColumnName = relation.references.identifies || relation.references.mapping.Model.identifiedBy; return this[relation.type](relation.references.mapping.Model, fkName, referencedColumnName); }; } createQuery(item, options = required(\"options\")) { /* eslint complexity: 0 */ const query = this.dbContext.knex(this.tableName); if (item) { query.where(this.identifiedBy, item.get(this.identifiedBy)); } if (this.discriminator) { query.andWhere(this.discriminator); } if (options &amp;&amp; options.transacting) { query.transacting(options.transacting); } return query; } raw(...args) { return this.dbContext.knex.raw(...args); } } module.exports = BookshelfMapping; × Search results Close "},"DBMappingRegistry.js.html":{"id":"DBMappingRegistry.js.html","title":"Source: DBMappingRegistry.js","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Source: DBMappingRegistry.js \"use strict\"; const ModelFactory = require(\"./ModelFactory\"); let instance; /** * Holds all Mappings and converts them to Bookshelf Models */ class DBMappingRegistry { constructor(ModelFactory) { this.mappings = {}; this.compiled = {}; this.ModelFactory = ModelFactory; } static getInstance() { if (!instance) { instance = new DBMappingRegistry(ModelFactory); } return instance; } /** * Register a Mapping * @param {string} name - Name of the mapping * @param {string} dbContextName - DB context / connection name * @param {BookshelfMapping} mapping - Mapping description of columns, relations etc. */ register(name, dbContextName, mapping) { if (this.isRegistered(name)) { throw new Error(`A mapping with name '${name}' is already registered`); } this.mappings[name] = { dbContextName: dbContextName, mapping: mapping }; } get(name) { return this.mappings[name].mapping; } isRegistered(name) { return name in this.mappings; } /** * Compile a BookshelfMapping for use with an EntityRepository * @param {string} name - Name of a registered Mapping * @returns {EntityRepository} compiled Mapping, ready to use */ compile(name) { if (!this.isCached(name)) { this.compileAndCache(name); } return this.compiled[name]; } compileAndCache(name) { if (!this.isRegistered(name)) { throw new Error(name + \" is not a registered mapping\"); } const factory = this.ModelFactory.context[this.mappings[name].dbContextName]; const mapping = Object.create(this.get(name)); if (mapping.relations) { mapping.relations.forEach((relation) =&gt; { const getCompiled = this.compile.bind(this, relation.references.mapping); Object.defineProperty(relation.references, \"mapping\", { get() { return getCompiled(); } }); }); } this.compiled[name] = factory.createModel(mapping); } isCached(name) { return name in this.compiled; } } module.exports = DBMappingRegistry; × Search results Close "},"EntityRepository.js.html":{"id":"EntityRepository.js.html","title":"Source: EntityRepository.js","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Source: EntityRepository.js \"use strict\"; const Q = require(\"q\"); const _ = require(\"underscore\"); const BookshelfRepository = require(\"./BookshelfRepository\"); const BookshelfModelWrapper = require(\"./BookshelfModelWrapper\"); const BookshelfDeepOperation = require(\"./BookshelfDeepOperation\"); const { required } = require(\"./Annotations\"); /** * Abstraction on top of BookshelfRepository, Bookshelf and Knex. Provies basic CRUD operations for a specific type. */ class EntityRepository { /** * @param {Class | Function} Entity - Class or constructor function. Entities from this repository will be instances of this Type * @param {BookshelfMapping} Mapping - {@link DBMappingRegistry#compile Compiled Mapping} which describes this type and its relations */ constructor(Entity, Mapping) { this.Entity = Entity; this.Mapping = Mapping; this.wrapper = new BookshelfModelWrapper(Mapping, Entity); this.repository = new BookshelfRepository(Mapping); } /** * Create new instance of Entity. * @param {object} [flatModel] - Simple object representation of Entity, e.g. after deserializing JSON. Properties missing in Mapping are dropped * @returns {Entity} - Instance of Entity, with given properties if any */ newEntity(flatModel) { return this.wrapper.createNew(flatModel); } /** * Fetch one Entity from this Repository * @param {ID} id - Identifier of Entity, specified in Mapping by \"identifiedBy\" * @param {object} [options] - Bookshelf fetch options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @param {Array&lt;string&gt;} [options.exclude] - Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" * @returns {Promise&lt;Entity|null&gt;} - Returns Promise resolved with entity, or null if not found */ findOne(id, options = null) { return this.repository.findOne(id, options).then((item) =&gt; this.wrapper.wrap(item)); } /** * Fetch all Entities, or Entities with given Ids from this Repository * @param {Array&lt;ID&gt;} ids - Identifiers of Entities, specified in Mapping by \"identifiedBy\" * @param {object} [options] - Bookshelf fetch options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @param {Array&lt;string&gt;} [options.exclude] - Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" * @returns {Promise&lt;Array&lt;Entity&gt;&gt;} - Returns Promise resolved with array of entities, or empty list if not found. * If ids were specified, Entities are sorted statically by given ids */ findAll(ids, options = null) { return this.repository.findAll(ids, options).then((item) =&gt; this.wrapper.wrap(item)); } /** * Fetch Entities using a query * @param {Function} q - Callback, used as Bookshelf/Knex where condition. * @param {object} [options] - Bookshelf fetch options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @param {Array&lt;string&gt;} [options.exclude] - Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" * @returns {Promise&lt;Array&lt;Entity&gt;&gt;} - Returns Promise resolved with array of entities, or empty list if not found. */ findAllWhere(q, options = null) { return this.repository.findWhere(q, options).then((items) =&gt; { return items.length ? this.wrapper.wrap(items) : []; }); } /** * Fetch Entity using a query * @param {Function} q - Callback, used as Bookshelf/Knex where condition. * @param {object} [options] - Bookshelf fetch options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @param {Array&lt;string&gt;} [options.exclude] - Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" * @returns {Promise&lt;Entity|null&gt;} - Returns Promise resolved with entity, or null if not found */ findWhere(q, options = null) { return this.repository.findWhere(q, options).then((items) =&gt; { if (items.length) { return this.wrapper.wrap(items.pop()); } else { return null; } }); } findByConditions(conditions, options = null) { return this.repository.findByConditions(conditions, options).then((items) =&gt; { return items.length ? this.wrapper.wrap(items) : []; }); } /** * Save one or multiple Entities to this Repository * @param {Entity | Array&lt;Entity&gt;} entity - Entity or Entities to save * @param {object} [options] - Bookshelf save options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @param {string} [options.method] - Specify \"update\" or \"insert\". Defaults to \"update\", or \"insert\" if Id is null * @returns {Promise&lt;Entity | Array&lt;Entity&gt;&gt;} - Returns Promise resolved with saved entity, or array of saved entities */ save(entity, options = null) { if (Array.isArray(entity)) { return Q.all(entity.map((entity) =&gt; this.save(entity, options))); } return this.executeTransactional(() =&gt; { return this.repository.save(this.wrapper.unwrap(entity), options).then((item) =&gt; this.wrapper.wrap(item)); }, options).tap((entity) =&gt; { this.afterSave(entity[this.Mapping.identifiedBy]); }); } /** * Hook, is called once after every successful save operation * @param {ID} id - Identifier of saved Entity */ afterSave() { } /** * Remove one or multiple Entities from this Repository * @param {Entity | Array&lt;Entity&gt; | ID | Array&lt;ID&gt;} entity - Entity or Entities, Id or Ids to remove * @param {object} [options] - Bookshelf save options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @returns {Promise&lt;Void&gt;} - Returns Promise resolved after removal */ remove(entity, options = null) { if (Array.isArray(entity)) { return Q.all(entity.map((entity) =&gt; this.remove(entity, options))); } else if (entity instanceof this.Entity) { entity = this.wrapper.unwrap(entity); } return this.executeTransactional(() =&gt; { return this.repository.remove(entity, options); }, options).tap(() =&gt; { const id = _.isObject(entity) ? entity[this.Mapping.identifiedBy] : +entity; if (id) { this.afterRemove(id); } }); } /** * Hook, is called once after every successful remove operation * @param {ID} id - Identifier of removed Entity */ afterRemove() { } /** * Execute an operation in a running or new transaction * @param {Function} operation - Callback to execute in a transaction * @param {object} options - Bookshelf options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @returns {Promise&lt;*&gt;} - Promise resolved with result of operation. If operation fails, Promise is rejected */ executeTransactional(operation, options = null) { if (options &amp;&amp; options.transactional &amp;&amp; !options.transacting) { return this.Mapping.startTransaction((t) =&gt; { options.transacting = t; return Q.try(operation).then(t.commit).catch(t.rollback); }); } else { return Q.try(operation); } } /** * Add an already started transaction to given query. If not yet started, no transaction will be added * @param {Transaction} [options.transacting] - Add Transaction object to given query * @param {KnexQuery} query - Add transaction to query, if one was started. * @param {object} options - Bookshelf options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @returns {KnexQuery} query - Returns KnexQuery for chaining */ addTransactionToQuery(query, options = required(\"options\")) { return BookshelfDeepOperation.addTransactionToQuery(query, options); } /** * Returns whether an Entity with the given Identifier exists. * @param {ID} id - Identifier * @param {object} [options] - Bookshelf save options * @param {Transaction} [options.transacting] - Run in given transaction * @param {boolean} [options.transactional] - Run in a transaction, start new one if not already transacting * @returns {Promise&lt;boolean&gt;} - Returns Promise resolved with flag indicating whether an Entity with the given Identifier exists */ exists(id, options = null) { if (!id) { return Q.when(false); } options = _.extend({}, options, { exclude: [\"*\"] }); return this.findOne(id, options).then((entity) =&gt; !!entity); } } module.exports = EntityRepository; × Search results Close "},"typedef_ColumnDescriptor.js.html":{"id":"typedef_ColumnDescriptor.js.html","title":"Source: typedef/ColumnDescriptor.js","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Source: typedef/ColumnDescriptor.js \"use strict\"; /** * Describes a Column in BookshelfMapping * @property {string} name - name of the column * @property {string} type - type of the column: \"sql\" or \"json\" * @property {Function} get - for type sql, this getter creates an sql snipped to get the value * @property {Function} set - for type sql, this setter creates an sql snipped to set the value */ class ColumnDescriptor { } module.exports = ColumnDescriptor; × Search results Close "},"typedef_ReferenceDescriptor.js.html":{"id":"typedef_ReferenceDescriptor.js.html","title":"Source: typedef/ReferenceDescriptor.js","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Source: typedef/ReferenceDescriptor.js \"use strict\"; /** * Describes a reference in BookshelfMapping * @property {string} mapping - Describes Referenced Entity or ValueObject * @property {Class} [type = Object] - Referenced Entities or ValueObjects are instances of this type * @property {string} [mappedBy = relation.name + _id] - FK name * @property {string} [identifies = identifiedBy] - By default takes the identifiedBy column of referenced entity and applies discriminators * together with harmonisation condition. If set to some column name then discriminators are omitted what may be used to create relation to * a unique revision of referenced entity * @property {boolean} [orphanRemoval = false] - Remove all orphans upon save/remove * @property {boolean} [cascade = false] - Save/remove objects of this relation * @property {boolean} [saveSequential = false] - Force sequential saving of this relation objects. * Useful e.g. when dealing with foreign table wrapper tables to avoid transaction errors. */ class ReferenceDescriptor { } module.exports = ReferenceDescriptor; × Search results Close "},"typedef_RelationDescriptor.js.html":{"id":"typedef_RelationDescriptor.js.html","title":"Source: typedef/RelationDescriptor.js","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Source: typedef/RelationDescriptor.js \"use strict\"; /** * Describes a relation in BookshelfMapping * @property {string} name - Name of the Relation. * @property {ReferenceDescriptor} references - Describes Referenced Entity or ValueObject * @property {string} type - Multiplicity. Getters and Setters area created in Entity. Values are: * \"hasOne\" (FK is in this entity) * \"belongsTo\" (FK is in referenced entity) * \"hasMany\" (1:n or m:n relation). No setter, but modifier methods in Entity (\"add\" / \"remove\" + relation.name) */ class RelationDescriptor { } module.exports = RelationDescriptor; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Classes Classes BookshelfMapping DBMappingRegistry EntityRepository ColumnDescriptor ReferenceDescriptor RelationDescriptor × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Bookshelf ORMAn OR-Mapping tool which features Bookshelf, the Repository Pattern an Persistence Ignorance Start here: EntityRepository DBMappingRegistry BookshelfMapping × Search results Close "},"BookshelfMapping.html":{"id":"BookshelfMapping.html","title":"Class: BookshelfMapping","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Class: BookshelfMapping BookshelfMapping Describes a DB Mapping new BookshelfMapping() Properties: Name Type Argument Default Description tableName string Fully qualified name of DB Table identifiedBy string &lt;optional&gt; \"id\" Primary key column columns Array.&lt;(String|ColumnDescriptor)&gt; &lt;optional&gt; columns to fetch. 'underscore_space' will be converted to 'lowerCamelCase' in Entity discriminator Object | function &lt;optional&gt; Fetch only Entities which match a given query, Knex where condition onDelete Object &lt;optional&gt; Execute instead of regular delete statement, Knex update statement keepHistory Boolean &lt;optional&gt; false Keep an History History in this table. New states are appended instead of updated. Columns 'revision_id' and 'parent_id' will be added to mapping, thus requires these columns in DB. 'revision_id' must have a unique default value, is the Primary Key at best. 'identifiedBy' must not be the Primary Key, since many revisions with the same ID can exist. historyColumns Boolean &lt;optional&gt; { revisionId: \"revision_id\", parentId: \"parent_id\" } Configure alias for history columns relations Array.&lt;RelationDescriptor&gt; &lt;optional&gt; Managed relations of this Entity. There will be a getter and setter for n:1 relations There will be a getter and modifiers (\"add\"/\"remove\" + relation.name) for m:n relations Source: BookshelfMapping.js, line 27 × Search results Close "},"DBMappingRegistry.html":{"id":"DBMappingRegistry.html","title":"Class: DBMappingRegistry","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Class: DBMappingRegistry DBMappingRegistry Holds all Mappings and converts them to Bookshelf Models new DBMappingRegistry() Source: DBMappingRegistry.js, line 9 Methods register(name, dbContextName, mapping) Register a Mapping Parameters: Name Type Description name string Name of the mapping dbContextName string DB context / connection name mapping BookshelfMapping Mapping description of columns, relations etc. Source: DBMappingRegistry.js, line 31 compile(name) Compile a BookshelfMapping for use with an EntityRepository Parameters: Name Type Description name string Name of a registered Mapping Source: DBMappingRegistry.js, line 55 Returns: compiled Mapping, ready to use Type EntityRepository × Search results Close "},"EntityRepository.html":{"id":"EntityRepository.html","title":"Class: EntityRepository","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Class: EntityRepository EntityRepository Abstraction on top of BookshelfRepository, Bookshelf and Knex. Provies basic CRUD operations for a specific type. new EntityRepository(Entity, Mapping) Parameters: Name Type Description Entity Class | function Class or constructor function. Entities from this repository will be instances of this Type Mapping BookshelfMapping Compiled Mapping which describes this type and its relations Source: EntityRepository.js, line 14 Methods newEntity( [flatModel]) Create new instance of Entity. Parameters: Name Type Argument Description flatModel object &lt;optional&gt; Simple object representation of Entity, e.g. after deserializing JSON. Properties missing in Mapping are dropped Source: EntityRepository.js, line 32 Returns: Instance of Entity, with given properties if any Type Entity findOne(id [, options]) Fetch one Entity from this Repository Parameters: Name Type Argument Default Description id ID Identifier of Entity, specified in Mapping by \"identifiedBy\" options object &lt;optional&gt; null Bookshelf fetch options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting exclude Array.&lt;string&gt; &lt;optional&gt; Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" Source: EntityRepository.js, line 45 Returns: Returns Promise resolved with entity, or null if not found Type Promise.&lt;(Entity|null)&gt; findAll(ids [, options]) Fetch all Entities, or Entities with given Ids from this Repository Parameters: Name Type Argument Default Description ids Array.&lt;ID&gt; Identifiers of Entities, specified in Mapping by \"identifiedBy\" options object &lt;optional&gt; null Bookshelf fetch options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting exclude Array.&lt;string&gt; &lt;optional&gt; Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" Source: EntityRepository.js, line 59 Returns: Returns Promise resolved with array of entities, or empty list if not found. If ids were specified, Entities are sorted statically by given ids Type Promise.&lt;Array.&lt;Entity&gt;&gt; findAllWhere(q [, options]) Fetch Entities using a query Parameters: Name Type Argument Default Description q function Callback, used as Bookshelf/Knex where condition. options object &lt;optional&gt; null Bookshelf fetch options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting exclude Array.&lt;string&gt; &lt;optional&gt; Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" Source: EntityRepository.js, line 72 Returns: Returns Promise resolved with array of entities, or empty list if not found. Type Promise.&lt;Array.&lt;Entity&gt;&gt; findWhere(q [, options]) Fetch Entity using a query Parameters: Name Type Argument Default Description q function Callback, used as Bookshelf/Knex where condition. options object &lt;optional&gt; null Bookshelf fetch options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting exclude Array.&lt;string&gt; &lt;optional&gt; Relation names to exclude, deep relations in dot notation. Specify wildcards using \"*\" Source: EntityRepository.js, line 87 Returns: Returns Promise resolved with entity, or null if not found Type Promise.&lt;(Entity|null)&gt; save(entity [, options]) Save one or multiple Entities to this Repository Parameters: Name Type Argument Default Description entity Entity | Array.&lt;Entity&gt; Entity or Entities to save options object &lt;optional&gt; null Bookshelf save options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting method string &lt;optional&gt; Specify \"update\" or \"insert\". Defaults to \"update\", or \"insert\" if Id is null Source: EntityRepository.js, line 112 Returns: Returns Promise resolved with saved entity, or array of saved entities Type Promise.&lt;(Entity|Array.&lt;Entity&gt;)&gt; afterSave(id) Hook, is called once after every successful save operation Parameters: Name Type Description id ID Identifier of saved Entity Source: EntityRepository.js, line 128 remove(entity [, options]) Remove one or multiple Entities from this Repository Parameters: Name Type Argument Default Description entity Entity | Array.&lt;Entity&gt; | ID | Array.&lt;ID&gt; Entity or Entities, Id or Ids to remove options object &lt;optional&gt; null Bookshelf save options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting Source: EntityRepository.js, line 139 Returns: Returns Promise resolved after removal Type Promise.&lt;Void&gt; afterRemove(id) Hook, is called once after every successful remove operation Parameters: Name Type Description id ID Identifier of removed Entity Source: EntityRepository.js, line 161 executeTransactional(operation, options) Execute an operation in a running or new transaction Parameters: Name Type Default Description operation function Callback to execute in a transaction options object null Bookshelf options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting Source: EntityRepository.js, line 172 Returns: Promise resolved with result of operation. If operation fails, Promise is rejected Type Promise.&lt;*&gt; addTransactionToQuery(query, options) Add an already started transaction to given query. If not yet started, no transaction will be added Parameters: Name Type Argument Description options.transacting Transaction &lt;optional&gt; Add Transaction object to given query query KnexQuery Add transaction to query, if one was started. options object Bookshelf options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting Source: EntityRepository.js, line 192 Returns: query - Returns KnexQuery for chaining Type KnexQuery exists(id [, options]) Returns whether an Entity with the given Identifier exists. Parameters: Name Type Argument Default Description id ID Identifier options object &lt;optional&gt; null Bookshelf save options Properties Name Type Argument Description transacting Transaction &lt;optional&gt; Run in given transaction transactional boolean &lt;optional&gt; Run in a transaction, start new one if not already transacting Source: EntityRepository.js, line 204 Returns: Returns Promise resolved with flag indicating whether an Entity with the given Identifier exists Type Promise.&lt;boolean&gt; × Search results Close "},"ColumnDescriptor.html":{"id":"ColumnDescriptor.html","title":"Class: ColumnDescriptor","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Class: ColumnDescriptor ColumnDescriptor Describes a Column in BookshelfMapping new ColumnDescriptor() Properties: Name Type Description name string name of the column type string type of the column: \"sql\" or \"json\" get function for type sql, this getter creates an sql snipped to get the value set function for type sql, this setter creates an sql snipped to set the value Source: typedef/ColumnDescriptor.js, line 10 × Search results Close "},"ReferenceDescriptor.html":{"id":"ReferenceDescriptor.html","title":"Class: ReferenceDescriptor","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Class: ReferenceDescriptor ReferenceDescriptor Describes a reference in BookshelfMapping new ReferenceDescriptor() Properties: Name Type Argument Default Description mapping string Describes Referenced Entity or ValueObject type Class &lt;optional&gt; Object Referenced Entities or ValueObjects are instances of this type mappedBy string &lt;optional&gt; relation.name + _id FK name identifies string &lt;optional&gt; identifiedBy By default takes the identifiedBy column of referenced entity and applies discriminatorstogether with harmonisation condition. If set to some column name then discriminators are omitted what may be used to create relation toa unique revision of referenced entity orphanRemoval boolean &lt;optional&gt; false Remove all orphans upon save/remove cascade boolean &lt;optional&gt; false Save/remove objects of this relation saveSequential boolean &lt;optional&gt; false Force sequential saving of this relation objects.Useful e.g. when dealing with foreign table wrapper tables to avoid transaction errors. Source: typedef/ReferenceDescriptor.js, line 16 × Search results Close "},"RelationDescriptor.html":{"id":"RelationDescriptor.html","title":"Class: RelationDescriptor","body":" Bookshelf ORM Classes BookshelfMappingDBMappingRegistryEntityRepositoryColumnDescriptorReferenceDescriptorRelationDescriptor Class: RelationDescriptor RelationDescriptor Describes a relation in BookshelfMapping new RelationDescriptor() Properties: Name Type Description name string Name of the Relation. references ReferenceDescriptor Describes Referenced Entity or ValueObject type string Multiplicity. Getters and Setters area created in Entity. Values are: \"hasOne\" (FK is in this entity) \"belongsTo\" (FK is in referenced entity) \"hasMany\" (1:n or m:n relation). No setter, but modifier methods in Entity (\"add\" / \"remove\" + relation.name) Source: typedef/RelationDescriptor.js, line 12 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
